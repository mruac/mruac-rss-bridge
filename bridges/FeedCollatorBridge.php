<?php

class FeedCollatorBridge extends FeedExpander
{
    const MAINTAINER = 'mruac';
    const NAME = 'Feed Collator';
    const URI = 'http://github.com/RSS-Bridge/rss-bridge/';
    const DESCRIPTION = 'Collates multiple items into one item.<br>Suitable for feeds of frequent, but small items.';
    const PARAMETERS = [[
        'url' => [
            'name' => 'Feed URI',
            'exampleValue' => 'https://lorem-rss.herokuapp.com/feed?length=42',
            'required' => true
        ],
        'max_items' => [
            'name' => 'Max number of items for an item (max 20)',
            'type' => 'number',
            'defaultValue' => 10,
            'required' => true,
            'title' => 'Maximum number of items to collate into a single item.'
        ],
        'max_time' => [
            'name' => 'Minimum minutes to collate over (Min 30)',
            'type' => 'number',
            'defaultValue' => 30,
            'required' => true,
            'title' => 'Maximum number of items to collate into a single item.'
        ],
        'str_seperator' => [
            'name' => 'Text seperator (Optional, used if provided)',
            'type' => 'text',
            'exampleValue' => '====================',
            'title' => 'Text used to seperate items.'

        ],
        'hr_seperators' => [
            'name' => 'Number of horizontal rules to seperate items',
            'type' => 'number',
            'defaultValue' => 1,
            'title' => 'Used if Text Seperator is not set.'
        ]
    ]];
    // const CACHE_TIMEOUT = 300; //seconds to keep cached returned feed (5 mins)
    const CACHE_TIMEOUT = 0; //seconds to keep cached returned feed (5 mins)
    const CACHE_LIMIT = 100; //adjust the feed's cache size here.
    private $hrSeperator;
    private $strSeperator;
    private $maxItems = 10;
    private $maxTime;

    /*
    this bridge should act as an rss reader for the rss readers. It tracks, collates items and publishes collated items, and the rss readers only receives the collated items.
    1. initial collate, then track
    2. upon each update from the tracker, collate as needed.
    3. if rss reader requests the bridge to return items, the bridge only returns the collated items.

    Parameters:
    Maximum number of collated items for a single published item (max_items)
    Minimum number of minutes to collate over a period of time (min_minutes)

    Each time the rss reader requests an update through the bridge, the bridge runs the tracker, collates, then returns published items.
    Request -> Bridge > Check tracker (collate if new items) > return collated items.
    This method will inevitably prevent frequently requesting rss readers from getting the absolute latest items, _until_ the age of that latest item reaches older than min_minutes
    Therefore, the feed generated by this bridge will be delayed from the latest item by min_minutes, unless enough items are published by the original feed to push it over max_items

    Collation logic:


    TESTME: this should keep it in groups of maxItems UNLESS there has been no new updates since the last fetch. 
    */

    public function collectData()
    {
        $this->strSeperator = e($this->getInput('str_seperator'));
        $hrSeperatorMultiplier = $this->getInput('hr_seperators') < 0 ? 1 : $this->getInput('hr_seperators');
        $this->hrSeperator = str_repeat('<hr>', $hrSeperatorMultiplier);
        $this->maxTime = $this->getInput('max_time') < 0 ? self::CACHE_TIMEOUT :  $this->getInput('max_time') * 60;
        $input = $this->getInput('max_items');
        if ($input < 0) {
            $this->maxItems = 1;
        } else if ($input > 20) {
            $this->maxItems = 20;
        } else {
            $this->maxItems = $input;
        }

        $url = $this->getInput('url');
        if (preg_match('#^http(s?)://#i', $url)) {
            $this->collectExpandableDatas($url);
        } else {
            throw new Exception('URI must begin with http(s)://');
        }

        //sort oldest to newest
        $collectedItems = array_reverse($this->items);

        $previousFetch = $this->loadCacheValue('previousFetch', []);
        $this->printGrouped('previousFetch (cache)', $this->minimise($previousFetch));

        //compare and check with $collated and exclude any overlaps with the previous fetch
        $lastPreviousFetchItem = $previousFetch[count($previousFetch) - 1];
        if (!is_null($lastPreviousFetchItem)) {
            //keep whatever is after $lastPreviousFetchItem
            $key = array_search($lastPreviousFetchItem, $collectedItems);
            if ($key !== false) {
                array_splice($collectedItems, 0, $key + 1);
            }
        }

        //[RSS-Bridge item, RSS-Bridge item, RSS-Bridge item, ...]
        array_push($previousFetch, ...$collectedItems);
        $this->saveCacheValue('previousFetch', $previousFetch, 86400); //24 hrs
        $this->printGrouped('maxItems ' . $this->maxItems . ', collectedItems', $this->minimise($collectedItems));

        //group RSS-Bridge items by number of maxItems
        $groupedItems = [];
        $collectedItemsCopy = $collectedItems;

        //[[RSS-Bridge item, ...* maxItems]...]
        while (count($collectedItemsCopy) > 0) {
            array_push($groupedItems, array_splice($collectedItemsCopy, 0, $this->maxItems));
        }
        $this->printGrouped('groupedItems', $this->minimisegrouped($groupedItems));

        //remove last group of RSS-Bridge items if less than maxItems AND the difference from last fetch is not older than maxTime.
        //keep if no new update from last fetch.
        //TODO: restructure cache to hold the finished processed grouped items instead of the raw items.
        //when fetching a new cache, remove duplicates and process as normal.
        //it is because of this block there are cases when a published grouped items can be less than 10.
        //FIXME: this doesn't work
        //NOTE:WIP - currently only returns the latest n items
        if (
            count($groupedItems[count($groupedItems) - 1]) < $this->maxItems &&
            $groupedItems[count($groupedItems) - 1]['timestamp'] - $collectedItems[count($collectedItems) - 1]['timestamp'] < $this->maxTime
        ) {
            unset($groupedItems[count($groupedItems) - 1]);
        }

        $this->printGrouped('remove last group <\br>this is used to present', $this->minimisegrouped($groupedItems));

        //turn each grouped RSS-Bridge items into an RSS-Bridge item.
        $this->items = $this->processCollatedItems($groupedItems);

        //trim older caches to limit cache size.
        if ($previousFetch >  $this->maxItems * 10) {
            $previousFetch = array_splice($previousFetch, $this->maxItems * 5);
            $this->saveCacheValue('previousFetch', $previousFetch);
        }
    }

    private function processCollatedItems(array $groupedItems)
    {
        $processed = [];

        foreach ($groupedItems as $itemGroup) {
            $lastCollatedItem = &$itemGroup[count($itemGroup) - 1];
            $firstCollatedItem = &$itemGroup[0];
            $firstUTCDateTime = gmdate("Y-m-d H:i", $firstCollatedItem['timestamp']) . ' UTC+0';
            $lastUTCDateTime = gmdate("Y-m-d H:i", $lastCollatedItem['timestamp']) . ' UTC+0';

            $content = '';
            for ($i = 0; $i < count($itemGroup); $i++) {
                $content .= $this->stringifyItem($itemGroup[$i]);
                if ($i < count($itemGroup) - 1) {
                    //if strSeperator === '' then it is no input, preferring to use hrSeperator
                    $content .= $this->strSeperator !== '' ? $this->strSeperator : $this->hrSeperator;
                }
            }

            $RSSBridge_item = [];
            // $item['uri'] = '';
            $RSSBridge_item['title'] = "Collated from $firstUTCDateTime to $lastUTCDateTime";
            $RSSBridge_item['timestamp'] = $lastCollatedItem['timestamp'];
            $RSSBridge_item['author']   = 'RSS-Bridge';
            $RSSBridge_item['content'] =  $content;
            $RSSBridge_item['uid'] =  $lastCollatedItem['timestamp'];
            $processed[] = $RSSBridge_item;
        }

        return $processed;
    }

    private function stringifyItem(array $item): string
    {
        $res = '<p>';

        $author = strlen($item['author']) > 0 ? " by <i>{$item['author']}</i>" : '';
        $time = gmdate("Y-m-d H:i", $item['timestamp']) . ' UTC+0';
        $res .= "<a href=\"{$item['uri']}\"><b>{$item['title']}</b>$author</a> at $time";

        if (isset($item['enclosures']) && count($item['enclosures']) > 0) {
            $res .= '<br>Enclosures: ';
            foreach ($item['enclosures'] as $enclosure) {
                $mime = parse_mime_type($enclosure);
                $res .= "<a href=\"$enclosure\">$mime</a> ";
            }
        }

        if (strlen($item['content']) > 0) {
            $res .= ":<p>{$item['content']}</p>";
        }

        $res .= '</p>';
        return $res;
    }


    private function minimise($array)
    {
        return array_map(function ($item) {
            return ['timestamp' => $item['timestamp']];
        }, $array);
    }

    private function minimisegrouped($array)
    {
        return array_map(function ($group) {
            return array_map(function ($item) {
                return ['timestamp' => $item['timestamp']];
            }, $group);
        }, $array);
    }

    private function printGrouped($msg, $array)
    {
        $aaa = preg_replace('/^\s*({|},|})\n/m', '', json_encode($array, JSON_PRETTY_PRINT));
        print($msg . ': <pre>' . $aaa . '</pre><br>');
        return;
    }

    public function getURI()
    {
        return $this->getInput('url');
    }
}
